program SslSkeleton (output, sslFile, inStream, outStream, optionFile);

    {        Computer Systems Research Group
        University of Toronto
        File:        New S/SL Table Walker (PT Pascal) V1.09
        Author:        J.R. Cordy
        Date:        4 January 1980  (Revised 22 April 1981)        }

    { Copyright (C) 1980  The University of Toronto }

    {        This program is the PT Pascal interpreter for 
      Syntax/Semantic Language programs.  A Parser
      will consist of this program plus the Syntax
      Language representation of the syntax of the language.
      Semantic Passes will each consist of this program
      plus the Syntax/Semantic Language representation
      of the semantic processing to be done and the
      Semantic Mechanisms for the pass, which
      implement the semantic operations required for
      the pass.  The S/SL Processor itself is a hybrid
      which parses and handles semantics in the same
      pass.                                                }

    {        A Syntax/Semantic Language (S/SL) program must be
      processed by the S/SL Processor, which will output
      PT Pascal declarations for the constants defining
      the input tokens, output tokens, error codes,
      type values and semantic operation codes used in
      the S/SL program and a file containing the values
      of the S/SL table for the program.
        The declarations must be merged into the constant
      declarations for this program.  The table file is
      read into the sslTable array as part of initialization
      of the walker.                                                }



    const
        { Primitive S/SL Table Operations:
          These will remain the same independent of the
          pass and form the fundamental table operations. }
        firstTableOperation = 0;
        firstPrimitiveOperation = 0;
        oCall = 0;
        oReturn = 1;
        oRuleEnd = 2;
        oJumpBack = 3;
        oJumpForward = 4;
        oInput = 5;
        oInputAny = 6;
        oInputChoice = 7;
        oEmit = 8;
        oError = 9;
        oChoice = 10;
        oChoiceEnd = 11;
        oSetParameter = 12;
        oSetResult = 13;
        lastPrimitiveOperation = 13;

        { Pass Dependent Semantic Operations:
          These will be different for each pass.  The
          semantic operations are implemented by the
          Semantic Mechanisms of the pass.
          There are two basic kinds of semantic operations:
          Update operations, which cause an update to the
          Semantic Mechanism, and Choice operations, which
          return a value based on the state of the Semantic
          Mechanism which is then used as the tag in a semantic
          choice.  Both Update and Choice operations may be
          parameterized by a single constant value.                }
        firstSemanticOperation = 14;
        oUpdateOperation = 14;        { Example only }
        oChoiceOperation = 15;        { Example only }
        lastSemanticOperation = 15;
        lastTableOperation = lastSemanticOperation;

        { The S/SL Table Size and Table Value Range;
          These definitions are generated by the S/SL Processor. }
        sslTblSize = 1;  { Null Table }
        minSslTableValue = -32767;
        maxSslTableValue = 32767;

        { The S/SL Rule Call Stack Size }
        sslStkSize = 127;

        { Maximum Source Lines }
        maxLineNumber = 9999;

        { S/SL System Failure Codes }
        firstFailureCode = 0;
        fSemanticChoiceFailed = 0;
        fChoiceRuleFailed = 1;
        lastFailureCode = 1;

        { Error Signal Codes }
        firstErrorCode = 0;
        eNoError = 0;
        eSyntaxError = 1;
        ePrematureEndOfFile = 2;
        eExtraneousProgramText = 3;
        { Pass dependent non-fatal error codes go here }

        firstFatalErrorCode = 10;
        eSslStackOverflow = 10;
        { Pass dependent fatal error codes go here }
        lastErrorCode = 10;

        { Maximum Error Count }
        maxErrors = 20;

        { Input Tokens }
        firstInputToken = -1;

        { Nonexistent input token used only in syntax error recovery }
        tSyntaxError = -1;

        { Compound Input Tokens }
        firstCompoundToken = 0;
        tInteger = 0;
        { Other compound input tokens go here }
        lastCompoundToken = 0;

        { Non-Compound Input Tokens }
        tSemicolon = 10;        { Example values only }
        tNewLine = 11;
        tEndOfFile = 12;
        { Other non-compound input tokens go here }
        lastInputToken = 12;

        { Output Tokens }
        firstOutputToken = 0;
        aOutputToken = 0;
        lastOutputToken = 0;

        { Constants associated with the Semantic Mechanisms
          of the pass go here.                                        }


    type
        { Input Token Type }
        InputTokens = firstInputToken .. lastInputToken;

        { Output Token Type }
        OutputTokens = firstOutputToken .. lastOutputToken;

        { Error Code Type }
        ErrorCodes = firstErrorCode .. lastErrorCode;

        { S/SL System Failure Code Type }
        FailureCodes = firstFailureCode .. lastFailureCode;

        { Types associated with the Semantic Mechanisms of the
          pass go here.                                                }


    var
        { The Syntax/Semantic Table;
          The S/SL table file produced by the S/SL Processor 
          for the pass is read into this array during initialization. }
        sslTable:
            packed array [0 .. sslTblSize] of 
                minSslTableValue .. maxSslTableValue;
        sslFile:
            file of integer;

        { Table Walker State }
        processing:
            Boolean  { initially true };
        sslPointer:
            0 .. sslTblSize  { initially 0 };
        operation:
            firstTableOperation .. lastTableOperation;

        { Tracing Control }
        optionFile:
            file of char;
        tracing:
            Boolean  { initially false };

        { Abort flag }
        abort:
            Boolean  { initially false};

        { The S/SL Rule Call Stack:
          The Rule Call Stack implements Syntax/Semantic
          Language rule call and return.
          Each time an oCall operation is executed,
          the table return address is pushed onto the
          Rule Call Stack.  When an oReturn is executed,
          the return address is popped from the stack.
          An oReturn executed when the Rule Call Stack is
          empty terminates table execution.                }
        sslStack:
            array [1 .. sslStkSize] of 0 .. sslTblSize;
        sslTop:
            0 .. sslStkSize  { initially 0 };

        { Choice Match Flag:
          Set by the Choice Handler to indicate whether
          a match was made or the otherwise path was taken.
          Set to true if a match was made and false otherwise.
          This flag is used in input choices to indicate
          whether the choice input token should be accepted or
          not.                                                        }
        choiceTagMatched:
            Boolean;

        { Parameterized And Choice Semantic Operation Values:
          These are used to hold the decoded parameter value to
          a parameterized semantic operation and the result
          value returned by a choice semantic operation
          or rule respectively.                                         }
        parameterValue:
            integer;
        resultValue:
            integer;

        { Line Counters }
        nextLineNumber:
            0 .. maxLineNumber        { initially 0 };
        lineNumber:
            0 .. maxLineNumber;

        { Error Counter }
        noErrors:
            0 .. maxErrors  { initially 0 };

        { Input Interface }
        inStream:
            file of InputTokens;
        nextInputToken:
            InputTokens;

        { The Compound Input Token Buffer;
          When a compound input token is accepted from
          the input stream, its associated value is
          saved in the compound token buffer for use by
          the Semantic Mechanisms of the pass.                }
        compndToken:
            InputTokens;        { Last compound input token accepted }
        compndValue:
            integer;                { Its associated value; often more than
                                 simply an integer }

        { Output Interface }
        outStream:
            file of OutputTokens;

        { Variables Used in Syntax Error Recovery }
        newInputLine:
            Boolean  { initially false };
        savedInputToken:
            InputTokens;

        { Global Temporaries }
        i: integer;
        j: integer;

        { The data structures associated with the Semantic Mechanisms
          for the pass go here.                                                }



    procedure SslAssert (assertion: Boolean; number: integer);
        { Procedure to implement programmer assertion checking
          with identification numbers.                                }
        begin
            if not assertion then
                begin
                    write ('### Assertion ', number: 1, ' failed');
                    writeln;
                    { Cause a crash }
                    case 2 of 1: end;
                end;
        end { SslAssert };


    procedure Error (errCode: ErrorCodes);
        { This procedure Emits the error message associated with errCode }
        begin
            SslAssert (errCode <> eNoError, 100);

            if errCode = eSyntaxError then
                { Syntax errors are in the lookahead token }
                write ('Line ', nextLineNumber: 1, ': ')
            else
                { Semantic errors are in the accepted token }
                write ('Line ', lineNumber: 1, ': ');

            case errCode of
                eSyntaxError:
                    write ('Syntax error');
                ePrematureEndOfFile:
                    write ('Unexpected end of file');
                eExtraneousProgramText:
                    write ('Extraneous program text');
                eSslStackOverflow:
                    write ('Nesting too deep');
            end;

            writeln;
            noErrors := noErrors + 1;

            if (errCode >= firstFatalErrorCode) or (noErrors = maxErrors) then
                begin
                    write ('*** Processing aborted');
                    writeln;
                    abort := true;
                    processing := false;
                end;
        end  { Error };


    procedure AcceptInputToken;
        { This procedure provides the interface to the
          previous pass;  it is reponsible for handling
          all input including line number indicators and
          the values and text associated with input tokens.  }
        var acceptedToken: InputTokens;
        begin
            SslAssert (nextInputToken <> tEndOfFile, 110);

            { Accept Token }
            acceptedToken := nextInputToken;

            { If the token is a compound token,
              read its associated value                    }
            if (acceptedToken > firstCompoundToken) and 
                    (acceptedToken < lastCompoundToken) then
                begin
                    compndToken := acceptedToken;
                    read (inStream, compndValue);
                end;

            { Update Line Number }
            lineNumber := nextLineNumber;

            { Read Next Input Token }
            newInputLine := false;
            repeat
                read (inStream, nextInputToken);

                if nextInputToken = tNewLine then
                    begin
                        { Update Line Counter and Set Flag }
                        newInputLine := true;

                        if nextLineNumber < maxLineNumber then
                            nextLineNumber := nextLineNumber + 1
                        else
                            nextLineNumber := 0;
                    end;
            until nextInputToken <> tNewLine;

            { Trace Input }
            if tracing then
                begin
                    write ('Input token accepted ', acceptedToken: 1,
                        ';  Line ', lineNumber: 1, ';  Next input token ',
                        nextInputToken: 1);
                    writeln;
                end;
        end { AcceptInputToken };


    procedure EmitOutputToken (emittedToken: OutputTokens);
        { Emit an output token to the output stream }
        begin
            write (outStream, emittedToken);

            { Trace Output }
            if tracing then
                begin
                    write ('Output token emitted ', emittedToken: 1);
                    writeln;
                end;
        end { EmitOutputToken };


    { The procedures used in implementing the Semantic Mechanisms
      of the pass go here.  These manipulate the Semantic Data Structures
      and implement the facilities used in the semantic operations. }


    { Syntax Error Handling }

    procedure SslGenerateCompoundInputToken (expectedToken: InputTokens);
        begin
            SslAssert ((nextInputToken = tSyntaxError) or
                    (nextInputToken = tEndOfFile), 120);
            compndToken := expectedToken;

            case expectedToken of
                tInteger:
                    compndValue := 0;
                { Other compound token cases go here }
            end;
        end { SslGenerateCompoundInputToken };


    procedure SslSyntaxError;
        { This procedure handles syntax errors in the input
          to the Parser pass; for Semantic passes this procedure
          will simply assert false since a syntax error in
          input would indicate an error in the previous pass.    }

        { Syntax error recovery:
          When a mismatch occurs between the the next input 
          token and the syntax table, the following recovery
          is employed.                                                }

        { If the expected token is tNewLine then if there
          has been no previous syntax error on the line,
          ignore the error.  (A missing logical new line
          is not a real error.)                                        }

        { If the expected token is tNewLine or tSemicolon and
          a syntax error has already been detected on the
          current logical line (flagged by nextInputToken =
          tSyntaxError), then flush the input until a
          new line or end of file is found.                        }

        { Otherwise, if this is the first syntax error
          detected on the line (flagged by nextInputToken
          <> tSyntaxError), then if the input token
          is tEndOfFile then emit the ePrematureEndOfFile
          error code and terminate execution.  Otherwise,
          emit the eSyntaxError error code and set
          the nextInputToken to tSyntaxError to prevent
          further input until the expected input is
          tSemicolon or tNewLine.                                }

        { If the expected token is not tSemicolon nor
          tNewLine and a syntax error has already been
          detected on the current line (flagged by
          nextInputToken = tSyntaxError), then do nothing
          and continue as if the expected token had
          been matched.                                        }
        begin
            SslAssert ((operation = oInput) or (operation = oInputAny), 130);

            if nextInputToken = tSyntaxError then
                begin
                    { Currently recovering from syntax error }
                    if (sslTable[sslPointer] = tNewLine)
                            or (sslTable[sslPointer] = tSemicolon) then
                        begin
                            { Complete recovery by synchronizing
                             input to a new line                         }
                            nextInputToken := savedInputToken;
                            newInputLine := false;
                            while (nextInputToken <> tSemicolon)
                                    and (nextInputToken <> tEndOfFile)
                                    and not newInputLine do
                                AcceptInputToken;
                        end;
                end
            else
                { First syntax error on the line }
                if sslTable[sslPointer] = tNewLine then
                    { Ignore missing logical newlines }
                    begin end
                else if nextInputToken = tEndOfFile then
                    begin
                        { Flag error and terminate processing }
                        Error (ePrematureEndOfFile);
                        processing := false;
                    end
                else
                    begin
                        { Flag error and begin recovery }
                        Error (eSyntaxError);
                        savedInputToken := nextInputToken;
                        nextInputToken := tSyntaxError;
                        lineNumber := nextLineNumber;
                    end;

            { If the expected input token is a compound 
             token, generate a dummy one.                }
            if sslTable[sslPointer] = tInteger
                    { or any other compound token } then
                SslGenerateCompoundInputToken (sslTable[sslPointer]);
        end { SslSyntaxError };


    procedure SslTrace;
        begin
            write ('Table index ', sslPointer-1: 1, ';  Operation ', 
                operation: 1, ';  Argument ', sslTable[sslPointer]: 1);
            writeln;
        end  { SslTrace };


    procedure SslFailure (failCode: FailureCodes);
        begin
            write ('### S/SL program failure:  ');

            case failCode of
                fSemanticChoiceFailed:
                    write ('Semantic choice failed');
                fChoiceRuleFailed:
                    write ('Choice rule returned without a value');
            end;

            writeln;
            write ('while processing line ', lineNumber);
            writeln;
            SslTrace;
            SslAssert (false, 140);
        end { SslFailure };


    procedure SslChoice (tag: integer);
        { This procedure performs both input and semantic
          choices.  It sequentially tests each alternative
          value against the tag value, and when a match is
          found, performs a branch to the corresponding
          alternative path.  If none of the alternative
          values matches the tag value, sslTable interpretation
          proceeds to the operation immediately following
          the list of alternatives (normally the otherwise
          path).  The flag choiceTagMatched is set to true
          if a match is found and false otherwise.                }
        var numberOfChoices:
            integer;
        begin
            sslPointer := sslPointer + sslTable[sslPointer];
            numberOfChoices := sslTable[sslPointer];
            sslPointer := sslPointer + 1;
            choiceTagMatched := false;

            repeat
                if sslTable[sslPointer] = tag then
                    begin
                        sslPointer := sslPointer + 1;
                        sslPointer := sslPointer - sslTable[sslPointer];
                        choiceTagMatched := true;
                        numberOfChoices := 0;
                    end
                else
                    begin
                        sslPointer := sslPointer + 2;
                        numberOfChoices := numberOfChoices - 1;
                    end;
            until numberOfChoices = 0;

        end { SslChoice };


    procedure SslWalker;
        var c: char;
        begin
            { Trace Execution if Required }
            tracing := false;
            reset (optionFile);

            if not eof (optionFile) then
                begin
                    read (optionFile, c);
                    tracing := (c = 't');
                end;

            { Initialize Table Walker State }
            processing := true;
            sslPointer := 0;
            sslTop := 0;
            noErrors := 0;
            abort := false;

            { Initialize Input/Output }
            reset (inStream);
            rewrite (outStream);
            nextInputToken := tNewLine;
            nextLineNumber := 0;
            newInputLine := false;
            AcceptInputToken;

            { Initialize Semantic Mechanisms }
            { Code to initialize the semantic mechanisms of the pass
             goes here.                                                }

            { Walk the S/SL Table }

            while processing do
                begin
                    operation := sslTable[sslPointer];
                    sslPointer := sslPointer + 1;

                    { Trace Execution }
                    if tracing then
                        SslTrace;

                    case operation of
                        oCall:
                            if sslTop < sslStkSize then
                                begin
                                    sslTop := sslTop + 1;
                                    { If using short (one-element) calls: }
                                    sslStack[sslTop] := sslPointer + 1;
                                    sslPointer := sslTable[sslPointer];

                                    { If using long (two-element) calls:
                                    sslStack[sslTop] := sslPointer + 2;
                                    sslPointer := sslTable[sslPointer] *
                                        (maxSslTableValue+1) +
                                        sslTable[sslPointer+1];
                                    }
                                end
                            else
                                begin
                                    Error (eSslStackOverflow);
                                    processing := false;
                                end;
                        oReturn:
                            if sslTop = 0 then
                                { Return from main S/SL procedure }
                                processing := false
                            else
                                begin
                                    sslPointer := sslStack[sslTop];
                                    sslTop := sslTop - 1;
                                end;
                        oRuleEnd:
                            SslFailure (fChoiceRuleFailed);
                        oJumpForward:
                            sslPointer := sslPointer + sslTable[sslPointer];
                        oJumpBack:
                            sslPointer := sslPointer - sslTable[sslPointer];
                        oInput:
                            begin
                                if sslTable[sslPointer] = nextInputToken then
                                    AcceptInputToken
                                else
                                    { Syntax error in input }
                                    SslSyntaxError;

                                sslPointer := sslPointer + 1;
                            end;
                        oInputAny:

                            if nextInputToken <> tEndOfFile then
                                AcceptInputToken
                            else
                                { Premature end of file }
                                SslSyntaxError;
                        oInputChoice:
                            begin
                                SslChoice (nextInputToken);

                                if choiceTagMatched then
                                    AcceptInputToken;
                            end;
                        oEmit:
                            begin
                                EmitOutputToken (sslTable[sslPointer]);
                                sslPointer := sslPointer + 1;
                            end;
                        oError:
                            begin
                                Error (sslTable[sslPointer]);
                                sslPointer := sslPointer + 1;
                            end;
                        oChoice:
                            SslChoice (resultValue);
                        oChoiceEnd:
                            SslFailure (fSemanticChoiceFailed);
                        oSetParameter:
                            begin
                                parameterValue := sslTable[sslPointer];
                                sslPointer := sslPointer + 1;
                            end;
                        oSetResult:
                            begin
                                resultValue := sslTable[sslPointer];
                                sslPointer := sslPointer + 1;
                            end;

                        { The Following Are Pass Dependent
                          Semantic Mechanism Operations          }
                        oUpdateOperation:
                            { Execute the Update Semantic Operation;
                             The parameter value for parameterized
                             operations is in "parameterValue"                }
                            ;
                        oChoiceOperation:
                            { Execute the Choice Semantic Operation;
                             Leave the result value in "resultValue".
                             The parameter value for parameterized 
                             operations is in "parameterValue"                 }
                            ;
                    end { case operation };

                end { while processing };

            if (nextInputToken <> tEndOfFile) and not abort then
                Error (eExtraneousProgramText);
        end { SslWalker };


    begin
        { Set Standard Characters }

        { Read in the S/SL Table }
        reset (sslFile);
        i := 0;
        repeat
            read (sslFile, j);
            SslAssert (i <= sslTblSize, 150);
            sslTable[i] := j;
            i := i + 1;
        until eof (sslFile);

        { Walk the S/SL Table }
        SslWalker;
    end { SslSkeleton }.
